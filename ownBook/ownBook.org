* overview
web moodleing is The appropriate application environments, knowledge acquisition and representation schemes are examined along with their relationship to contemporary web-based systems.

** World Wide Web (Web 1.0)
A system of interlinked, hypertext documents that runs over the Internet. Information represented in natural languages
- Documents contain graphics, multimedia, layouts
-  Suitable for human
- Web of documents connected by anchors
+ Uniform Resource Identifiers (URI) are used for documents and anchors
+ Underlying the Web is a set of messages that developers of web infrastructure have agreed to treat in a standard manner.
  - When a web server speaking HTTP receives a GET request, it should send back data corresponding to the path portion of the request message. The semantics of these messages have been thoroughly defined by standards committees and documented in W3C recommendations.
  - This standardized infrastructure allows web application developers to operate behind a facade that separates them from the details of how application data is transmitted between machines, and focus on how their applications appear to users.
  - Web application developers no longer need to coordinate with other developers about message formats or how applications should behave in the presence of certain data.

*** Basic Ideas
- Hypertext/hyperlink
- Resource Identifiers
  + Uniform Resource Identifiers (URIs) are short strings that identify resources in the web: documents, images, downloadable files, services, electronic mailboxes, and other resources.
- Markup language
+ characters or codes embedded in text which indicate structure, semantic meaning, or advice on presentation

The current (syntactic / structural) Web
[[./img/currentSyntacticStructuralWeb.png]]

Was the Web meant to be more?
[[./img/wasStructuralWeb.png]]


** Social Web (Web 2.0)
The Web where “ordinary” users can meet, collaborate, and share using social software applications on the Web (tagged content, social bookmarking, AJAX, etc.)
[[./img/web2.0.png]]

** Semantic Web – Web 3.0
Tim Berners-Lee has a vision of a Semantic Web which has machine-understandable semantics of information, and millions of small specialized reasoning services that provide support in automated task achievement based on the accessible information

** Ontology
The semantic Web is essentially based on ontologies.
 - ontologies are formal and consensual specifications of conceptualizations... (e.g. by OO Models, or Entity Relationship model)
 - Providing a shared and common understanding of a domain that can be communicated across people and application systems (not application specific, but consensual for a domain)
[[./img/simpleOntology.png]]

Ontologies describe concepts and their Relations.

Semantic Web - language tower
[[./img/LanguageTower.png]]

** What is Semantic Web for?
 - Integrating - trying to solve the problem of data and service integration.
 - Searching - Providing better communication between human and computers by adding machine-processable semantics to data.

Semantic Integration
[[./img/semanticIntegration.png]]

Semantic Searching
[[./img/semanticSearching.png]]

* Describing Web Resources: RDF
** Resource Description Framework
– A framework for representing information about resources in the Web
– Intended for situations in which information needs to be processed by applications (machine)
** RDF graphs
– Are sets of subject‐predicate‐object triples, where elements may be IRIs, blank nodes or datatyped literals.

** comparing data models
| Model        | Example format | Data                 | Metadate     | Identifier                      | Query syntax | Semantics (Meaning)              |   |   |   |   |   |   |   |
|--------------+----------------+----------------------+--------------+---------------------------------+--------------+----------------------------------+---+---+---+---+---+---+---|
| Relational   | Mysql, Oracle  | Table Cell values    | Table Column | Primary key (Data Column) value | SQL          | n/a                              |   |   |   |   |   |   |   |
| Hierarchical | XML            | Tag/Attribute Values | XSD/DTD      | Unique Attribute Key Value      | Xpath        | n/a                              |   |   |   |   |   |   |   |
| Graph        | RDF/XML,Turtle | RDF                  | RDFS/OWL     | URL                             | SPARQL       | Yes, using RDFS and RDFS and OWL |   |   |   |   |   |   |   |

* RDF: Graph-based Model
+ A graph of nodes and arcs representing the resources and their properties and values
+ A graph is a collection of triples
– Subject, predicate, object
– Represented as node‐arc‐node
– Predicate denotes a relationship
– Direction of arc is significant
+ Always point to the object

[[./img/graphBaseModel.jpg]]

[[./img/graphModelExample.png]]

URIrefs are shown as ellipses
Literals are shown as boxs


* Triples
RDF triple has the following structure: <subject> <predicate> <object>

** Example 1
John is the creator of the web page http://www.uow.edu.au/~john

– Subject (resource)
 + http://www.uow.edu.au/~john
– Predicate (property)
 + http://purl.org/dc/terms/creator
– Object (Literal)
 + John

- URIrefs are shown as ellipses
- Literals are shown as boxes

[[./img/triplesExampleOne.png]]

** example 2 (with blank node)
[[./img/blankNodeExample.png]]

** Summary
An RDF triple contains three components:
- The subject - which is an RDF URI reference or a blank node
- The predicate (also called property) - which is an RDF URI reference
- The object - which is an RDF URI reference, a literal or a blank node

Written in the order subject,predicate,object.

* Three kinds of nodes in RDF graph
** IRI (Internationalized Resource Identifier)
 - Can appear in all three positions of a triple
 - Are global identifiers and reusable
   + so other people can re-use the IRI to identify the same thing
 - IRI is a generalisation of URI
 - URL is a form of IRI

** Literals
 - Basic values that are not IRIs
 - Only appear in object position of a triple
 - Literals have datatypes that define range of possible value: strings, numbers, dates
 - Can be associated with a datatype
   + RDF re-uses many of the XML Schema built-in datatypes

** Blank nodes
- Denote resources without explicitly naming them with IRIs.
- Can appear in the subject or object position of a trople.
- Blank nodes do not identify specific resources.

**  RDF Vocabularies
- To support the definition of vocabularies RDF provides the RDF Schema language.
- This language allows one to define semantic characteristics of RDF data.

The main modeling constructs provided by RDF Schema are summarized in the table below:

RDF Schema Constructs

| Construct                 | Syntactic form           | Description                                  |
|---------------------------+--------------------------+----------------------------------------------|
| Class (a class)           | C rdf:type rdf:Property  | C (a resource) is an RDF class               |
| Property (a class)        | P rdf:type rdf:Property  | P (a resource) is an RDF property            |
| type (a property)         | I rdf:type C             | I (a resource) is an instance of C (a class) |
| subClassOf(a property)    | C1 rdfs:subClassOf C2    | C1 (a class) is a subclass of C2 (a class)   |
| subPropertyOf(a property) | P1 rdfs:subPropertyOf P2 | property of P2 (a property)                  |
| domain (a property)       | P rdfs:domain C          | domain of P (a property) is C (a class)      |
| range (a property)        | P rdfs:range C           | range of P (a property) is C (a class)       |

*** Example of RDF vocabularies used world wide
+ Friend of a friend (FOAF)
  - to describe social network
+ Dublin Core
  - maintains a metadate element set for describing a wide range of resources
+ schema.org
  - a vocabulary developed by a group of major search providers.
+ SKOS
  - is a vocabulary for publishing classification schemes such as terminologies and thesauri on the web

* Serialization formats
+ Turtle family of RDF languages
  - N-Triples, Turtle
+ RDF/XML (XML syntax for RDF).

N-Triples
- A line-based, plain text format for encoding an RDF graph.

N-Triples triples are a sequence of RDF terms representing the subject, predicate and object of an RDF Triple. These may be separated by white space (spaces U+0020 or tabs U+0009). This sequence is terminated by a '.' and a new line (optional at the end of a document).
* Turtle
- An extension of N-Triples
- Turtle introduces a number of syntactic shortcuts, such as support for namespace prefixes, list and shorthands for detatyped literals.
- Turtle provides a trade-off between ease of writing, ease of parsing and readability
* RDF/XML
RDF document represented by XML statement with the tag rdf:RDF

The content of the element is a number of descriptions which use rdf:Description tags
- Every description is a statement about a resource
  + An aboout attribute, referencing an existing resource
  + An ID attribute, creating a new resource
  + Without a name, creating an anonymous resource

** Example
#+BEGIN_SRC xml
<rdf:RDF>
  <rdf:Description
  about="http://www.w3.org/Home/Lassila">
  <s:Creator>Ora Lassila</s:Creator>
  </rdf:Description>
</rdf:RDF>
#+END_SRC

** Complete XML
#+BEGIN_SRC xml
<?xml version="1.0"?>
<rdf:RDF
   xmlns:rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns#
   xmlns:s="http://description.org/schema/">
   <rdf:Description about="http://www.w3.org/Home/Lassila">
      <s:Creator>Ora Lassila</s:Creator>
   </rdf:Description>
</rdf:RDF>
#+END_SRC

* Description element
  - The Description element names, in an about attribute, the resource to which each of the statements apply.
  - If the resource does not yet exist (i.e., does not yet have a resource identifier) then a Description element can supply the identifier for the resource using an ID attribute.

* Declaring the use of RDF
It is necessary to declare that RDF is being used so that applications can recognise this is an RDF/XML document.

** Example
<?xml version="1.0"?>
<!DOCTYPE rdf:RDF PUBLIC "-//DUBLIN CORE//DCMES DTD 2002/07/31//EN" "http://dublincore.org/documents/2002/07/31/dcmesxml/dcmes-xml-dtd.dtd">
<rdf:RDF
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:dc="http://purl.org/dc/elements/1.1/">

   <rdf:Description rdf:about="http://www.ilrt.bristol.ac.uk/people/cmdjb/">
      <dc:title>Dave Beckett's Home Page</dc:title>
      <dc:creator>Dave Beckett</dc:creator>
      <dc:publisher>ILRT, University of Bristol</dc:publisher>
      <dc:date>2002-07-31</dc:date>
   </rdf:Description>
</rdf:RDF>

* RDF/XML
- RDF document represented by XML statement with the tag rdf:RDF
- It is necessary to declare that RDF is being used so that applications can recognise this is an RDF/XML document.
- The content of the element is a number of descriptions which use rdf:Description tags
 + Every description is a statement about a resource
  - An about attribute, referencing an existing resource
  - An ID attribute, creating a new resource
  - Without a name, creating an anonymous resource
** Example 1
<?xml version="1.0"?>
<rdf:RDF
   xmlns:rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns#
   xmlns:s="http://description.org/schema/">
   <rdf:Description about="http://www.w3.org/Home/Lassila">
      <s:Creator>Ora Lassila</s:Creator>
   </rdf:Description>
</rdf:RDF>
** Example 2
<?xml version="1.0"?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22‐rdf‐syntax‐ ns#"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:ex="http://example.org/">
<rdf:Description rdf:about="http://www.w3.org/TR/rdf‐syntax‐ grammar" dc:title="RDF 1.1 XML Syntax">
   <ex:editor>
      <rdf:Description ex:fullName="Dave Beckett">
         <ex:homePage rdf:resource="http://purl.org/net/dajobe/"/>
      </rdf:Description>
   </ex:editor>
</rdf:Description>
</rdf:RDF>


<?xml version="1.0"?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22‐rdf‐syntax‐ns#"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:ex="http://example.org/">
   <rdf:Description rdf:about="http://www.w3.org/TR/rdf‐syntax‐grammar">
      <ex:editor>
          <rdf:Description>
             <ex:homePage>
                <rdf:Description rdf:about="http://purl.org/net/dajobe/"></rdf:Description>
             </ex:homePage>
             <ex:fullName>Dave Beckett</ex:fullName>
          </rdf:Description>
      </ex:editor>
      <dc:title>RDF 1.1 XML Syntax</dc:title>
   </rdf:Description>
</rdf:RDF>

[[./img/RDFexample2.png]]

* Containers
+ refer to a collection of resources
  – e.g. a list of students
+ three types of container objects
  – Bag (rdf: Bag)
  – Sequence (rdf: Seq )
  – Alternative (rdf: Alt)
+ Therefore the rdfs:Container class is a super‐class of rdf:Bag, rdf:Seq, rdf:Alt

** rdf:Bag
+ an unordered list of resources or literals
+ to declare a property with multiple values and there is no significance to the order in which the values are given.
  - e.g. a list of part numbers where order of processing is unimportant, duplicate values are permitted

[[./img/bag.png]]
*** example A list of favourite fruits: banana, apple and pear
#+BEGIN_SRC xml
<?xml version="1.0"?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
   <rdf:Bag rdf:about="http://example.org/favourite-fruit">
      <rdf:_1 rdf:resource="http://example.org/banana"/>
      <rdf:_2 rdf:resource="http://example.org/apple"/>
      <rdf:_3 rdf:resource="http://example.org/pear"/>
   </rdf:Seq>
</rdf:RDF>
#+END_SRC

** rdf:Seq
- an ordered list of resources or literals
- to declare a property with multiple values and order of the values is significant
 + e.g. alphabetical ordering of values, duplicate values are permitted

[[./img/containerSeq.jpg]]

*** example A list of favourite fruits: banana, apple and pear (in the order specified)
#+BEGIN_SRC xml
<?xml version="1.0"?>
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
   <rdf:Seq rdf:about="http://example.org/favourite-fruit">
      <rdf:_1 rdf:resource="http://example.org/banana"/>
      <rdf:_2 rdf:resource="http://example.org/apple"/>
      <rdf:_3 rdf:resource="http://example.org/pear"/>
   </rdf:Seq>
</rdf:RDF>

#+END_SRC
** rdf:Alt
+ a list of resources or literals for the single value of a property
 – e.g. provide alternative language translations for the title of the work, or to provide a list of Internet mirror sites at which the resource might be found
+ can choose any one of the items in the list as appropriate

[[./img/containerAlt.jpg]]

*** example A list of favourite fruits: banana, apple and pear (choose one from the list)
#+BEGIN_SRC xml

  <?xml version="1.0"?>
     <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
        <rdf:Alt rdf:about="http://example.org/favouritefruit">
           <rdf:_1 rdf:resource="http://example.org/banana"/>
           <rdf:_2 rdf:resource="http://example.org/apple"/>
           <rdf:_3 rdf:resource="http://example.org/pear"/>
        </rdf:Seq>
   </rdf:RDF>

#+END_SRC

** rdf:li
+ a convenient element to avoid having to explicitly number each member
 – list item

*** example A list of favourite fruits: banana, apple and pear
#+BEGIN_SRC xml
<?xml version="1.0"?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntaxns#">
<rdf:Seq rdf:about="http://example.org/favourite-fruit">
<rdf:li rdf:resource="http://example.org/banana"/>
<rdf:li rdf:resource="http://example.org/apple"/>
<rdf:li rdf:resource="http://example.org/pear"/>
</rdf:Seq>
</rdf:RDF>

#+END_SRC
** Predicate Lists in N‐Triple
+ Often the same subject will be referenced by a number of predicates.
+ use the ';' symbol to repeat the subject of triples that vary only in predicate and object RDF terms

*** Example
#+BEGIN_SRC xml
<http://example.org/#spiderman>  <http://www.perceive.net/schemas/relationship/enemyOf> <http://example.org/#green‐goblin> ;
<http://xmlns.com/foaf/0.1/name> "Spiderman" .
#+END_SRC
equivalent
#+BEGIN_SRC xml
<http://example.org/#spiderman> <http://www.perceive.net/schemas/relationship/enemyOf> <http://example.org/#green-goblin> .
<http://example.org/#spiderman> <http://xmlns.com/foaf/0.1/name> "Spiderman" .
#+END_SRC

** Object list in N‐Triple
+ Objects are repeated with the same subject and predicate.
+ the ',' symbol is used to repeat the subject and predicate of triples that only differ in the object RDF term.

*** Example
#+BEGIN_SRC xml
<http://example.org/#spiderman> <http://xmlns.com/foaf/0.1/name> "Spiderman", "Человек‐паук"@ru .
#+END_SRC

equivalent

#+BEGIN_SRC xml
<http://example.org/#spiderman> <http://xmlns.com/foaf/0.1/name> "Spiderman" .
<http://example.org/#spiderman> <http://xmlns.com/foaf/0.1/name> "Человек-паук"@ru .
#+END_SRC

** Turtle (Terse RDF Triple Language)
+ a more compact serialization of RDF
+ uses prefix
+ A prefixed name is a prefix label and a local part, separated by a colon ":"

*** Example
#+BEGIN_SRC xml
@base <http://example.org/> .
@prefix rdf: <http://www.w3.org/1999/02/22‐rdf‐syntax‐ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf‐schema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix rel: <http://www.perceive.net/schemas/relationship/> .

<#green‐goblin>
   rel:enemyOf <#spiderman> ;
   a foaf:Person ; # in the context of the Marvel universe
   foaf:name "Green Goblin" .

<#spiderman>
   rel:enemyOf <#green‐goblin> ;
   a foaf:Person ;
   foaf:name "Spiderman", "Человек‐паук"@ru .
#+END_SRC

*** Example
+ Define a prefix label
http://www.perceive.net/schemas/relationship/ as somePrefix
Then write   somePrefix:enemyOf

is equivalent to
<http://www.perceive.net/schemas/relationship/enemyOf>


** RDF Literals
#+BEGIN_SRC xml
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
<http://example.org/#green‐goblin> foaf:name
"Green Goblin" .
<http://example.org/#spiderman> foaf:name
"Spiderman" .
#+END_SRC

** RDF Blank Nodes
+ In Turtle
– expressed as _: followed by a blank node label which is a series of name characters.
+ A fresh RDF blank node is allocated for each unique blank node label in a document. Repeated use of the same blank node label identifies the same RDF blank node.

*** Example
_:a <http://xmlns.com/foaf/0.1/name> "Alice" .
_:a <http://xmlns.com/foaf/0.1/knows> _:b .
_:b <http://xmlns.com/foaf/0.1/name> "Bob" .
_:b <http://xmlns.com/foaf/0.1/knows> _:c .
_:c <http://xmlns.com/foaf/0.1/name> "Eve" .
_:b <http://xmlns.com/foaf/0.1/mbox> <bob@example.com> .

** Collections
+ Collection structure for lists of RDF nodes
+ The Turtle syntax for Collections is a possibly empty list of RDF terms enclosed by ()

*** Example
@prefix : <http://example.org/foo> .
# the object of this triple is the RDF collection blank node
:subject :predicate ( :a :b :c ) .
# an empty collection value ‐ rdf:nil
:subject :predicate2 () .

*** RDF Collection
+ rdf:List
+ rdf:first
+ rdf:rest
+ rdf:nil

** The RDF Schema (RDFS)
+ Is a semantic extension of RDF
 – May impose special syntactic conditions or restrictions upon RDF graphs
+ It provides mechanisms for describing groups of related resources and the relationships between these resources
– e.g. we could define the eg:author property to have a domain of eg:Document and a range of eg:Person

*** Example
+ Types in RDF:
<#john, rdf:type, #Student>
+ What is a "#Student"?
– "#Student" identifies a category (a concept or a class)

We need a language for defining RDF types:
– Define classes:
 + "#Student is a class"
– Relationships between classes:
 + "#Student is a sub‐class of #Person"
– Properties of classes:
 + "#Person has a property hasName"
- RDF Schema is such a language

** RDFS: Class & Property
+ RDF Schema describes properties in terms of the classes of resource to which they apply.
+ This is the role of the domain and range mechanisms
 - Example,
   + eg:author property has a domain of eg:Document and a range of eg:Person,
   + whereas a classical object oriented system may define a class eg:Book with an attribute called eg:author of type eg:Person.
   + Using the RDF approach, it is easy for others to subsequently define additional properties with a domain of eg:Document or a range of eg:Person. This can be done without the need to re‐define the original description of these classes.
   + One benefit of the RDF property‐centric approach is that it allows anyone to extend the description of existing resources, one of the architectural principles of the Web
+ RDFS strategy is to acknowledge that there are many techniques through which the meaning of classes and properties can be described

** RDFS Vocabulary

+ RDFS Extends the RDF Vocabulary
+ RDFS summary can be found at the following link and https://www.w3.org/TR/rdf-schema/#ch_summary
+ Namespace rdfs: https://www.w3.org/TR/rdf-schema#

RDFS Classes
– rdfs:Resource
– rdfs:Class
– rdfs:Literal
– rdfs:Datatype
– rdfs:Container
– rdfs:ContainerMembershipProperty

RDFS Properties
– rdfs:domain
– rdfs:range
– rdfs:subPropertyOf
– rdfs:subClassOf
– rdfs:member
– rdfs:seeAlso
– rdfs:isDefinedBy
– rdfs:comment
– rdfs:label

RDFS Example
[[./img/rdfsExample.png]]

* Classes
+ Resources may be divided into groups called classes.
+ The members of a class are known as instances of the class.
rdfs: Class

** Subclass
+ If a class C is a subclass of a class C', then all instances of C will also be instances of C'.

rdfs:subClassOf

* Property
+ property -> characteristics of class

+ rdf: Property
– all properties in RDF are instances of class rdf:Property
– example: ex:age rdf:type rdf:Property

+ To describe property
– rdfs: domain
– rdfs:range
– rdfs:subPropertyOf

** rdfs:range
+ the values of a particular property
 - example
   + ex:hasMother rdfs:range ex:Female .
   + ex:age rdfs:range xsd:integer .

** rdfs:domain
+ a particular property applies to a designated class.

ex:Book rdf:type rdfs:Class .
ex:author rdf:type rdf:Property .
ex:author rdfs:domain ex:Book .

*** Example
#+BEGIN_SRC xml
<rdf:Property rdf:ID="registeredTo">
   <rdfs:domain rdf:resource="#MotorVehicle"/>
   <rdfs:range rdf:resource="#Person"/>
</rdf:Property>

<rdf:Property rdf:ID="rearSeatLegRoom">
   <rdfs:domain rdf:resource="#PassengerVehicle"/>
   <rdfs:range rdf:resource="&xsd;integer"/>
</rdf:Property>
#+END_SRC

*** RDF Schema Example
#+BEGIN_SRC xml
<rdf:RDF xml:base="http://example.org/univ-ont#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
   xmlns:univ="http://example.org/univ-ont#">

   <rdf:Property rdf:about="#teaches">
      <rdfs:domain rdf:resource="#Professor" />
      <rdfs:range rdf:resource="#Course" />
   </rdf:Property>

   <univ:Person rdf:about="#heflin" >
      <univ:teaches rdf:resource="#cse428" />
   </univ:Person>
</rdf:RDF>

#+END_SRC
[[./img/RDFSchemaExample.png]]

** rdfs:subPropertyOf
ex:driver rdf:type rdf:Property .
ex:primaryDriver rdf:type rdf:Property .
ex:primaryDriver rdfs:subPropertyOf ex:driver .

*** RDF/XML
<rdf:Property rdf:ID="driver">
<rdfs:domain rdf:resource="#MotorVehicle"/>
</rdf:Property>
<rdf:Property rdf:ID="primaryDriver">
<rdfs:subPropertyOf rdf:resource="#driver"/>
</rdf:Property>


*** Example of Instance
#+BEGIN_SRC xml
<ex:PassengerVehicle rdf:ID="johnSmithsCar">
   <ex:registeredTo rdf:resource="http://www.example.org/staffid/85740"/>
      <ex:rearSeatLegRoom rdf:datatype="&xsd;integer">127</ex:rearSeatLegRoom>
      <ex:primaryDriver rdf:resource="http://www.example.org/staffid/85740"/>
</ex:PassengerVehicle>
#+END_SRC


* Limitations of expressive power of RDF schema
** RDF/RDFS
– organise vocabularies in typed hierarchies: subclass and subproperty relationships, domain and range restrictions, and instances of classess
** missing
– local scope of properties
 + e.g. rdfs:range defines the range of a property say eats for all classes, but RDF schema cannot declare range restrictions that apply to some classes only, e.g. we cannot say cows eat only plants while other animals may eat meat

** disjointness of classess
– e.g. male and female are disjoint
– but in RDF schema, we can only state subclass relationship, e.g. female is a subclass of person

** boolean combinations of classes
– sometimes we wish to build new classes by combining other classes using union, intersection, complement.
 + e.g. we wish to define the class person to be disjoint union of classes male and female. RDF schema does not allow.

** cardinality restrictions
– to place restrictions on how many distinct values a property may or may not take
 + e.g. a person has exactly two parents, a course is taught by at least one lecturer
 + not possible to express in RDF schema

** special characteristics of properties
– RDF schema cannot allow properties such as inverse (eats and is eaten by) to express


* OWL 2
+ OWL = Web Ontology Language
 – is a language for expressing ontologies
 – An ontology provides the means for describing explicitly the conceptualization behind the knowledge represented in a knowledge base.
 – Ontologies are the backbone of the Semantic Web.
 – They provide the knowledge that is required for semantic applications of all kinds.

* Notes
OWL 2 is not a programming language:
– It is declarative, i.e. it describes a state of affairs in a logical way
 + is a knowledge representation language designed to formulate, exchange and reason with knowledge about a domain of interest
– Then reasoners can be used to infer further information about that state of affairs.
– How these inferences are realized algorithmically is not part of the OWL document but depends on the specific implementations.

** Requirements for ontology language
- Allow users to write explicit, formal conceptualisations of domain models
- Well‐defined syntax
- Efficient reasoning support
- Formal semantics
- Sufficient expressive power
- Convenience of expression

** Formal semantics
- Describes the meaning of knowledge precisely
 + Precisely: does not open to different interpretations by different people/machine
- Allow people to reason about the knowledge
 + Class membership
  - If x is an instance of a class C, and C is a subclass of D, then we infer x is an instance of D
– Equivalence of class
 + If class A is equivalent to class B, and class B is equivalent to class C, then A is equivalent to C.

** Reasoning about knowledge
+ Consistency
 – Suppose we have declared x to be an instance of class A and A is a subclass of B [intersection] C, A is a subclass of D and B and D are disjoint, then we have inconsistency because A should be empty but has an instance x. This is an indication of error.
+ Classification
– If we have declared that certain property‐value pairs are a sufficient condition for memberships in a class A, then if an individual x satisfies such conditions, we can conclude that x must be an instance of A.

* Three sublanguages of OWL
+ OWL Full
+ OWL DL (Descriptive Logic)
+ OWL Lite

** OWL Lite
+ Supports those users primarily needing a classification hierarchy and simple constraints.
+ Thesauri and other taxonomies.

** OWL DL
+ Supports those users who want the maximum expressiveness while retaining computational completeness (all conclusions are guaranteed to be computable) and decidability (all computations will finish in finite time).

+ So named due to its correspondence with description logics

** OWL Full
+ Maximum expressiveness and the syntactic freedom of RDF with no computational guarantees.
+ It is unlikely that any reasoning software will be able to support complete reasoning for every feature of OWL Full.

** The following set of relations hold; but not their inverses
+ Every legal OWL Lite ontology is a legal OWL DL ontology.
+ Every legal OWL DL ontology is a legal OWL Full ontology.
+ Every valid OWL Lite conclusion is a valid OWL DL conclusion.
+ Every valid OWL DL conclusion is a valid OWL Full conclusion.

** OWL Lite
+ Class
+ rdfs: subClassOf
+ rdf: Property
+ rdfs: subPropertyOf
+ rdfs: domain
+ rdfs: range
+ Individual

** OWL Lite Equality and Inequality
+ equivalentClass
+ equivalentProperty
+ sameAs
+ differentAs
+ AllDifferent

*** equivalentClass
+ Two classes may be stated to be equivalent.
+ Equivalent classes have the same instances.
+ Equality can be used to create synonymous classes.
 - Example
   + Car can be stated to be equivalentClass to Automobile.
   + From this a reasoner can deduce that any individual that is an instance of Car is also an instance of Automobile and vice versa

*** equivalentProperty
+ Two properties may be stated to be equivalent.
+ Equivalent properties relate one individual to the same set of other individuals.
+ Equality may be used to create synonymous properties.
  - Example
    + hasLeader may be stated to be the equivalentProperty to hasHead.
    + From this a reasoner can deduce that if X is related to Y by the property hasLeader, X is also related to Y by the property hasHead and vice versa.
    + A reasoner can also deduce that hasLeader is a subproperty of hasHead and hasHead is a subProperty of hasLeader.

*** sameAs
+ Two individuals may be stated to be the same.
+ Example:
  - The individual Deborah may be stated to be the same individual as DeborahMcGuinness.

*** differentFrom
+ An individual may be stated to be different from other individuals.
 - Example
   + the individual Frank may be stated to be different from the individuals Deborah and Jim.
   + Thus, if the individuals Frank and Deborah are both values for a property that is stated to be functional (thus the property has at most one value), then there is a contradiction.

*** AllDifferent
+ A number of individuals may be stated to be mutually distinct.
+ Example,
  – Frank, Deborah, and Jim could be stated to be mutually distinct using the AllDifferent construct.
  – The AllDifferent construct is particularly useful when there are sets of distinct objects and when modelers are interested in enforcing the unique names assumption within those sets of objects.

* Property characteristics
+ ObjectProperty
+ DatatypeProperty
+ inverseOf
+ TransitiveProperty
+ SymmetricProperty
+ FunctionalProperty
+ InverseFunctionalProperty

** inverseOf
- If some property links individual a to individual b, then its inverse property will link individual b to individual a
- Example,
 if hasChild is the inverse of hasParent Matthew hasParent Jean then a reasoner can deduce that Jean hasChild Matthew

[[./img/inverseOf.png]]

** TransitiveProperty
If a property P is transitive, and the property relates to individual a to individual b and also individual b to individual c, then we infer that a is related to c via property P.

[[./img/TransitiveProperty.png]]

** SymmetricProperty
If a property P is symmetric and the property relates individual a to individual b then individual b is also related to individual a via property P.

[[./img/SymmetricProperty.png]]

** FunctionalProperty
- for a given individual, there is at most one individual that is related to the individual via the property
- also known as single valued (unique) property

[[./img/FunctionalProperty.png]]

** InverseFunctionalProperty
If a properties is inverse functional it means the inverse property is functional

[[./img/InverseFunctionalProperty.png]]

** OWL Lite Property Restrictions –how many values can be used.
+ allValuesFrom
– this property on this particular class has a local range restriction associated with it.
+ someValuesFrom
– A particular class may have a restriction on a property that at least one value for that property is of a certain type.

** OWL Lite Restricted Cardinality – concerning cardinalities of value 0 or 1
+ minCardinality
  – minCardinality = 1 then any instance of that class will be related to at least one individual by that property.
  – minCardinality = 0, then the property is optional with respect to a class.

+ maxCardinality
  – maxinCardinality = 1 then any instance of that class will be related to at most one individual by that property.
  - maxCardinality = 0, then the property is no value with respect to that property.

+ Cardinality
  – Provided as convenience when it is useful to state a property on a class has both minCardinality 0 and maxCardinality 0 or both minCardinality 1 and maxCardinality 1

** OWL Lite Class Intersection
+ intersectionOf
  – intersections of named classes and restrictions.
+ Example
– the class EmployedPerson can be described as the intersectionOf Person and EmployedThings
– From this a reasoner may deduce that any particular EmployedPerson has at least one employer

* Ontology
+ Formalized vocabularies of terms, often covering a specific domain and shared by a community of users.
  – They specify the definitions of terms by describing their relationships with other terms in the ontology.
+ An ontology is a set of precise descriptive statements about some part of the world.

** Structure of OWL 2

[[./img/StructureOfOWL2.png]]

** Different Syntaxes
| Name of Syntax    | Specification                  | Status                    | Purpose                                                                |
|-------------------+--------------------------------+---------------------------+------------------------------------------------------------------------|
| RDF/XML           | Mapping to RDF Graphs, RDF/XML | Mandatory                 | Interchange (can be written and read by all conformant OWL 2 software) |
| OWL/XML           | XML Serialization              | Optional                  | Easier to process using XML tools                                      |
| Functional Syntax | Structural Specification       | Optional                  | Easier to see the formal structure of ontologies                       |
| Manchester Syntax | Manchester Syntax              | Optional                  | Easier to read/write DL Ontologies                                     |
| Turtle            | Mapping to RDF Graphs, Turtle  | Optional, Not from OWL-WG | Easier to read/write RDF triples                                       |

** OWL Syntax
+ An OWL ontology is an RDF graph -> a set of RDF triples
 – The meaning of an OWL ontology is solely determined by RDF graph
+ OWL is a vocabulary extension of RDF
+ The built-in vocabulary for OWL comes from OWL namespace owl: http://www.w3.org/2002/07/owl#

** OWL 2: Modeling knowledge
+ OWL 2 is a knowledge representation knowledge, designed to formulate, exchange and reason with knowledge about a domain of interest.
+ Basic notions:
 – Axioms: the basic statements that an OWL ontology expresses
 – Entities: elements used to refer to real-world objects
 – Expressions: combinations of entities to form complex descriptions from basic ones

** To formulate knowledge explicitly
+ Ontology consists of statements (or propositions)
 – Example of statements
  + It is raining
  + Every man is mortal
+ These statements are called axioms

** OWL 2 Ontology
+ is a collection of axioms
 - ontology asserts that its axioms are true

** In OWL 2
+ Objects as individuals
+ Categories as classes
+ Relations as properties
+ Note: A class is a name and collection of properties that describe a set of individuals

** OWL statements
+ Made up of atomic statements
 – Mary is female
 - John and Mary are married
+ Objects: Mary, John
+ Categories: female
+ Relations: married
+ All atomic constituents are called entities

** Properties in OWL 2
+ Object properties relate objects to objects
 – A person to their spouse
+ Datatype properties assign data values to objects
 – An age to a person.
+ Annotation properties are used to encode information about the ontology itself
 – Author and creation date

** Constructors
+ Names of entities can be combined into expressions using constructors
 – atomic classes: female, professor
 - combined conjunctively to form class expressions: female professors
+ This way, expressions = new entities

** Functional-Style syntax
+ is designed to be easier for specification purposes and to provide a foundation for the implementation of OWL 2 tools such as APIs and reasoners.

** ClassAssertion
+ Functional-style syntax -> ClassAssertion( :Person :Mary )
+ RDF/XML syntax -> <Person rdf:about="Mary"/>
+ Mary belongs to the class of all Persons
+ Note: one individual can belong to many classes simultaneously ClassAssertion( :Woman :Mary )

** Class Hierarchies
+ Functional-style syntax -> SubClassOf( :Woman :Person)
+ RDF/XML syntax
#+BEGIN_SRC xml
<owl:Class rdf:about="Woman">
   <rdfs:subClassOf rdf:resource="Person"/>
</owl:Class>
#+END_SRC
+ able to specify generalization relationships of all classes

** Equivalent Class
+ Functional-style syntax -> EquivalentClasses( :Person :Human)
+ RDF/XML syntax
#+BEGIN_SRC xml
<owl:Class rdf:about="Person">
   <owl:equivalentClass rdf:resource="Human"/>
</owl:Class>
#+END_SRC

** Disjoint Class
+ Functional-style syntax -> DisjointClasses( :Woman :Man)
+ RDF/XML syntax
#+BEGIN_SRC xml
<owl:AllDisjointClasses>
   <owl:members rdf:parseType="Collection">
      <owl:Class rdf:about="Woman"/>
      <owl:Class rdf:about="Man"/>
   </owl:members>
</owl:AllDisjointClasses>
#+END_SRC

** Inferencing Example
+ The disjointness axiom can be used to deduce
 – Mary is not a Man
 – Mother and Man are disjoint

** Object properties
+ Functional-style syntax -> ObjectPropertyAssertion(:hasWife :John :Mary)
+ RDF/XML syntax
#+BEGIN_SRC xml
<rdf:Description rdf:about="John">
   <hasWife rdf:resource="Mary"/>
</rdf:Description>
#+END_SRC

** Negative Property
+ Functional-style syntax -> NegativeObjectPropertyAssertion(:hasWife :Bill :Mary)
+ RDF/XML syntax
#+BEGIN_SRC xml
<owl:NegativePropertyAssertion>
   <owl:sourceIndividual rdf:resource="Bill"/>
   <owl:assertionProperty rdf:resource="hasWife"/>
   <owl:targetIndividual rdf:resource="Mary"/>
</owl:NegativePropertyAssertion>
#+END_SRC

** Property Hierarchies
+ Functional-style syntax -> SubObjectPropertyOf(:hasWife :hasSpouce)
+ RDF/XML syntax
#+BEGIN_SRC xml
<owl:ObjectProperty rdf:about="hasWife">
   <rdfs:subPropertyOf rdf:resource="hasSpouse"/>
</owl:ObjectProperty>
#+END_SRC

** Domain and Range restrictions
+ Functional-style syntax -> ObjectPropertyDomain(:hasWife :Man) --- ObjectPropertyRange(:hasWife :Woman)
+ RDF/XML syntax
#+BEGIN_SRC xml
<owl:ObjectProperty rdf:about="hasWife">
   <rdfs:domain rdf:resource="Man"/>
   <rdfs:range rdf:resource="Woman"/>
</owl:ObjectProperty>
#+END_SRC

** Equality and Inequality of individuals
+ Functional-style syntax
 - DifferentIndividuals(:John :Bill)
 - SameIndividuals(:James :Jim)

+ RDF/XML syntax
#+BEGIN_SRC xml
<rdf:Description rdf:about="John">
   <owl:differentFrom rdf:resource="Bill"/>
</rdf:Description>

<rdf:Description rdf:about="James">
   <owl:sameAs rdf:resource="Jim"/>
</rdf:Description>
#+END_SRC

** Datatypes
+ Relates individuals to data values
+ Use XML schema datatypes
+ Functional-style syntax
 - DataPropertyAssertion(:hasAge :John “51”^^xsd:integer)

+ RDF/XML syntax
#+BEGIN_SRC xml
<Person rdf:about="John">
   <hasAge
      rdf:datatype="http://www.w3.org/2001/XMLSchema#integer">51<
   /hasAge>
</Person>
#+END_SRC

** NegativeDataPropertyAssertion
+ Functional-style syntax -> NegativeDataPropertyAssertion( :hasAge :Jack "53"^^xsd:integer )
+ RDF/XML syntax
#+BEGIN_SRC xml
<owl:NegativePropertyAssertion>
<owl:sourceIndividual rdf:resource="Jack"/>
<owl:assertionProperty rdf:resource="hasAge"/>
<owl:targetValue
   rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"> 53
</owl:targetValue>
</owl:NegativePropertyAssertion>
#+END_SRC

** Complex classes
+
#+BEGIN_SRC xml
EquivalentClasses(
   :Mother
   ObjectIntersectionOf(:Woman:Parent)
)
#+END_SRC
+
#+BEGIN_SRC xml
EquivalentClasses(
   :Parent
   ObjectUnionOf( :Mother :Father )
)
#+END_SRC
+
#+BEGIN_SRC xml
EquivalentClasses(
   :ChildlessPerson
   ObjectIntersectionOf(
      :Person
      ObjectComplementOf( :Parent )
   )
)
#+END_SRC

** Property restrictions
+ Use constructors involving properties
+ Existential quantification
 – Defines a class as the set of all individuals that are connected via a particular property to another individual which is an instance of a certain class.
   + Natural language indicators for the usage of existential quantification are words like “some,” or “one.”

+ Universal quantification
 – Describe a class of individuals for which all related individuals must be instances of a given class.
  + Natural language indicators for the usage of universal quantification are words like “only,” “exclusively,” or “nothing but.”

*** Existential quantification
• For every instance of Parent, there exists at least one child, and that child is a member of the class Person.
#+BEGIN_SRC xml
EquivalentClasses(
   :Parent
   ObjectSomeValuesFrom( :hasChild :Person )
)
#+END_SRC

*** Universal quantification
+ Somebody is a happy person exactly if all their children are happy persons
#+BEGIN_SRC xml
EquivalentClasses(
   :HappyPerson
   ObjectAllValuesFrom( :hasChild :HappyPerson )
)
#+END_SRC

** Property Cardinality Restrictions
+ To specify the number of individuals involved in the restriction
#+BEGIN_SRC xml
ClassAssertion(
   ObjectMaxCardinality( 4 :hasChild :Parent)
   :John
)

ClassAssertion(
   ObjectMinCardinality( 2 :hasChild :Parent)
   :John
)

ClassAssertion(
   ObjectExactCardinality( 2 :hasChild :Parent)
   :John
)
#+END_SRC

** Enumeration of Individuals
#+BEGIN_SRC xml
EquivalentClasses(
   :MyBirthdayGuests
   ObjectOneOf( :Bill :John :Mary)
)
#+END_SRC

+ Classes defined this way are sometimes referred to as closed classes or enumerated sets
– Bill, John, and Mary are the only members of MyBirthdayGuests

** Advanced property characteristics
InverseObjectProperties( :hasParent :hasChild )
SymmetricObjectProperty( :hasSpouse )
AsymmetricObjectProperty( :hasChild )
DisjointObjectProperties(:hasParent :hasSpouse )
ReflexiveObjectProperty( :hasRelative )
IrreflexiveObjectProperty( :parentOf )
FunctionalObjectProperty( :hasHusband )
InverseFunctionalObjectProperty( :hasHusband )
TransitiveObjectProperty( :hasAncestor )

** Property chains
#+BEGIN_SRC xml
SubObjectPropertyOf(
   ObjectPropertyChain( :hasParent :hasParent)
   :hasGrandparent
)
#+END_SRC
+ Enable hasGrandparent property to be defined more specific
+ hasGrandparent connects all individuals that are linked by a chain of exactly two hasParent properties

** Keys
+ Each named instance of the class expressions is uniquely identified by a set of values
HasKey( :Person () ( :hasSSN ) )

** Advanced Use of Datatypes
#+BEGIN_SRC xml
DatatypeDefinition(
   :personAge
   DatatypeRestriction( xsd:integer
   xsd:minInclusive "0"^^xsd:integer
   xsd:maxInclusive "150"^^xsd:integer)
)
#+END_SRC

*** Another example
#+BEGIN_SRC xml
DatatypeDefinition(
   :toddlerAge DataOneOf(
      "1"^^xsd:integer
      "2"^^xsd:integer )
)
#+END_SRC

** Annotations
+ Functional-style syntax
AnnotationAssertion( rdfs:comment :Person "Represents the set of all people." )
+ RDF/XML syntax
#+BEGIN_SRC xml
<owl:Class rdf:about="Person">
   <rdfs:comment>Represents the set of all people.</rdfs:comment>
</owl:Class>
#+END_SRC

** How is ontology different from XML or XML Schema
+ OWL Ontology -> knowledge representation
+ XML/XMLSchema -> message format
+ Most industry based web standards consist of a combination of message formats and protocol specifications -> operational semantics
+ OWL 2 does not provide means to prescribe how a document should be structured syntactically

** Consider the following example
+ Upon receipt of this PurchaseOrder message, transfer Amount dollars from AccountFrom to AccountTo and ship Product
+ This specification is not designed to support reasoning outside the transaction context, e.g. Product is a type of Chardonnay therefore it must be a white wine.

** Advantage of OWL ontologies
+ Availability of reasoning tools that provide generic support that is not specific to the particular subject domain
+ Note: building a sound and useful reasoning system is not a simple effort.

** Considerations
+ Must consider which species of OWL (OWL Lite, OWL DL or OWL Full) meet their needs
+ OWL Lite vs. OWL DL
 – Depends on the extent to which users require the more expressive restriction constructs provided by OWL DL
+ OWL DL vs. OWL Full
– Depends on the extent to which users require metamodelling facilities of RDF Schema (i.e. defining classes of classes).
 + Reasoning support for OWL Full is less predicatable

** OWL 2 vs. Database
+ Closed-world assumption
 – If some fact is not present in the database, it is usually considered to be FALSE
+ Open-world assumption
 – If some fact is not present in ontology (OWL 2 document) it may simply be missing (but possibly true)

* SPARQL
** SPARQL Basic Queries
+ SPARQL is based on matching graph patterns
+ Most forms of SPARQL query contain a set of triple patterns called a basic graph pattern
+ Each of the subject, predicate and object may be a variable

** Example 1
*** Given the following triple
#+BEGIN_SRC xml
<http://example.org/book/book1>
<http://purl.org/dc/elements/1.1/title>
"SPARQL Tutorial" .
#+END_SRC

*** Question
– What is the title of book1?

*** Query
SELECT ?title
where
{
   <http://example.org/book/book1> <http://purl.org/dc/elements/1.1/title> ?title .
}

*** Query Result
"SPARQL Tutorial"

** Example 2 - Triple
@prefix :
 <http://aabs.purl.org/music#> .
:andrew :playsInstrument :guitar .

*** Query: which instrument does Andrew play?
#+BEGIN_SRC xml
PREFIX : <http://aabs.purl.org/music#>
SELECT ?instrument
WHERE {
      :andrew :playsInstrument ?instrument .
      }
#+END_SRC

*** Result
:guitar

** SPARQL SELECT
+ has two parts
 – a set of question words and a question pattern
 – WHERE indicate selection pattern

+ example
#+BEGIN_SRC xml
SELECT ?instrument WHERE {
   :andrew :playsInstrument ?instrument .}

SELECT ?who WHERE {
   ?who :playsInstrument :guitar .}

SELECT ?what WHERE {
   :andrew :?what :guitar .}
#+END_SRC

** Consider the following RDF graph
[[./img/sparqlRDFgraph.png]]

*** Question
+ Write a SPARQL query to find out the movies that JamesDean played in.
#+BEGIN_SRC xml
SELECT ?what
WHERE {
   :JamesDean :playrdIn ?what .}
#+END_SRC

** Consider the following RDF graph
[[./img/sparqlRDFgraphTwo.png]]

*** Question
+ Write a SPARQL query to find out the directors that direct the movies that JamesDean played in.
#+BEGIN_SRC xml
SELECT ?who
 WHERE {:JamesDean :playrdIn ?what .
        ?what :directedBy ?who .}
#+END_SRC

*** Result
?who
:GeorgeStevens
:EliaKazan
:NicholasRay
:FredGuiol

** Consider the following RDF graph
[[./img/sqarqlRDFgraphThree.png]]

*** Query
+ Write a SPARQL query to find the actresses who playedIn the same movies as JamesDean.
#+BEGIN_SRC xml
SELECT ?actress
WHERE {:JamesDean :playrdIn ?movie .
        ?actress :playedIn ?movie .
        ?actress rdf:type :Woman .}
#+END_SRC
** SELECT DISTINCT
+ You can use SELECT DISTINCT to filter out duplicate results
#+BEGIN_SRC xml
SELECT DISTINCT ?property ?value
WHERE ( :JamesDean ?property ?value)
#+END_SRC

** Multiple matches – Example 1
Given the following:
#+BEGIN_SRC xml
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
_:a foaf:name "Johnny Lee Outlaw" .
_:a foaf:mbox <mailto:jlow@example.com> .
_:b foaf:name "Peter Goodguy" .
_:b foaf:mbox <mailto:peter@example.org> .
_:c foaf:mbox <mailto:carol@example.org> .
#+END_SRC
*** Query
#+BEGIN_SRC xml
PREFIX foaf:
 <http://xmlns.com/foaf/0.1/>
SELECT ?name ?mbox
   WHERE
   { ?x foaf:name ?name .
   ?x foaf:mbox ?mbox }
#+END_SRC

*** Result

| name                | mailbox                    |
|---------------------+----------------------------|
| “Johnny Lee Outlaw” | <mailto:jlow@example.com>  |
| “Peter Goodguy”     | <mailto:peter@example.com> |

** Consider another example
@prefix foaf:<http://xmlns.com/foaf/0.1/> .
@prefix rdf:<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
_:a  rdf:type  foaf:Person .
_:a  foaf:name "Alice" .
_:a  foaf:mbox <mailto:alice@example.com> .
_:a  foaf:mbox <mailto:alice@work.example> .
_:b  rdf:type foaf:Person .
_:b  foaf:name "Bob" .

*** If this query is executed, what is the result?
#+BEGIN_SRC xml
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
SELECT ?name ?mbox
WHERE  { ?x foaf:name  ?name .
         OPTIONAL { ?x  foaf:mbox  ?mbox }
       }
#+END_SRC

*** Result
| name    | mbox                        |
|---------+-----------------------------|
| "Alice" | <mailto:alice@example.com>  |
| "Alice" | <mailto:alice@work.example> |
| "Bob"   |                             |

** Matching RDF Literals - Example
#+BEGIN_SRC xml
@prefix dt: <http://example.org/datatype#> . @prefix ns: <http://example.org/ns#> .
@prefix : <http://example.org/ns#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
:x ns:p "cat"@en .
:y ns:p "42"^^xsd:integer .
:z ns:p "abc"^^dt:specialDatatype .
#+END_SRC

*** Query 1
#+BEGIN_SRC xml
SELECT ?v
WHERE { ?v ?p “cat”}
#+END_SRC
**** What is the result?
No output

*** Query 2
#+BEGIN_SRC xml
SELECT ?v
WHERE { ?v ?p “cat”@en}
#+END_SRC

**** Result
<http://example.org/ns#x>

*** Query 3
#+BEGIN_SRC xml
SELECT ?v
WHERE { ?v ?p 42}
#+END_SRC

**** Result
<http://example.org/ns#y>

*** Query 4
#+BEGIN_SRC xml
SELECT ?v
WHERE {
?v ?p "abc"^^<http://example.org/datatype#specialDatatype>
}
#+END_SRC
**** Result
<http://example.org/ns#z>

*** Blank node labels
#+BEGIN_SRC xml
@prefix foaf:
 <http://xmlns.com/foaf/0.1/> .
_:a foaf:name "Alice" .
_:b foaf:name "Bob" .
#+END_SRC

** SPARQL – Filter
+ restrict solutions to whose for which the filter expression evaluates to be TRUE

*** Example
#+BEGIN_SRC xml
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix : <http://example.org/book/> .
@prefix ns: <http://example.org/ns#> .

:book1 dc:title "SPARQL Tutorial" .
:book1 ns:price 42 .
:book2 dc:title "The Semantic Web" .
:book2 ns:price 23 .
#+END_SRC
**** Query 1
#+BEGIN_SRC xml
PREFIX dc: <http://purl.org/dc/elements/1.1/>
SELECT ?title
WHERE {
   ?x dc:title ?title
   FILTER regex(?title, "^SPARQL")
}
#+END_SRC
***** Result
Title
"SPARQL Tutorial"

**** Query 2
#+BEGIN_SRC xml
PREFIX dc: <http://purl.org/dc/elements/1.1/>
prefix ns: http://example.org/ns#

SELECT ?title ?price
WHERE {
   ?x ns:price ?price
   FILTER (?price, <30.5)
   ?x dc:title ?title .
      }
#+END_SRC

***** Result
| Title              | price |
|--------------------+-------|
| "The Semantic Web" | 23    |

** CONSTRUCT
+ The SELECT query form returns variable bindings.
+ The CONSTRUCT query form returns an RDF graph.
*** Given the following data
@prefix org: <http://example.com/ns#> .
_:a org:employeeName "Alice" .
_:a org:employeeId 12345 .

_:b org:employeeName "Bob" .
_:b org:employeeId 67890 .

**** Query
#+BEGIN_SRC xml
  PREFIX foaf: <http://xmlns.com/foaf/0.1/>
  PREFIX org: <http://example.com/ns#>
  CONSTRUCT { ?x foaf:name ?name }
  WHERE  { ?x org:employeeName ?name }
#+END_SRC

***** Result
#+BEGIN_SRC xml
@prefix org: <http://example.com/ns#> .
_:x foaf:name "Alice" .
_:y foaf:name "Bob" .
#+END_SRC

** SPARQL built-in filter functions
+ Logical: !, &&, ||
+ Math: +, -, *, /
+ Comparison: =, !=, >, <, ...
+ SPARQLtests: isURI, isBlank, isLiteral, bound
+ SPARQLaccessors: str, lang, datatype
+ Other: sameTerm, langMatches, regex

*** Example 1
#+BEGIN_SRC xml
SELECT ?actor
WHERE {?actor :playedIn :EastOfEden .
FILTER (?birthday>”1930-01-01”^^xsd:date)}
#+END_SRC

*** Example 2
#+BEGIN_SRC xml
SELECT ?actor
WHERE {?actor :playedIn :EastOfEden .
?actor :bornOn ?birthday .
FILTER (?birthday>”1930-01-01”^^xsd:date)}
#+END_SRC

*** Example 3
#+BEGIN_SRC xml
SELECT ?actor
WHERE {
   ?actor :playedIn :EastOfEden .
   ?actor :bornOn ?birthday .
   FILTER (?birthday>”Jan 1, 1960”^^xsd:date)
   FILTER (?birthday<”Dec 31, 1969”^^xsd:date)
}
#+END_SRC

**** Notes
+ Cannot reference a variable in the FILTER if that variable has not been referenced in the graph pattern
+ If multiple filters are used, all tests must be TRUE to return a result

** Binding
+ A value is bound to a variable
  – Example ?actor is bound to JamesDean
+ A result is returned only when a value is bound to a variable, else it will not

** ASK
+ Asking a question
 – Return TRUE or FALSE
#+BEGIN_SRC xml
ASK WHERE {
  ?any :playedIn :GIANT .
  ?any :bornOn ?birthday .
  FILTER (?birthday > “1950-01-01”^^xsd:date)
}
#+END_SRC
*** Example 1
#+BEGIN_SRC xml
@prefix foaf:<http://xmlns.com/foaf/0.1/> .
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

_:a  foaf:name "Alice" .
_:a  foaf:homepage <http://work.example.org/alice/> .
_:b  foaf:name "Bob" .
_:b  foaf:mbox <mailto:bob@work.example> .

ASK  { ?x foaf:name  "Alice" }
#+END_SRC

**** Output
TRUE

*** Example 2
#+BEGIN_SRC xml
@prefix foaf:<http://xmlns.com/foaf/0.1/> .
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

_:a foaf:name "Alice" .
_:a foaf:homepage <http://work.example.org/alice/> .

_:b foaf:name "Bob" .
_:b foaf:mbox <mailto:bob@work.example> .

ASK  { ?x foaf:name  "Alice" ;
          foaf:mbox  <mailto:alice@work.example> }
#+END_SRC

**** Output
FALSE

** Limits and Ordering
#+BEGIN_SRC xml
SELECT ?title ?date
WHERE {
   :JamesDean :playedIn ?movie .
   ?movie rdfs:label ?title .
   ?movie dc:date ?date .
}
ORDER BY ?title
#+END_SRC

*** Another example
#+BEGIN_SRC xml
SELECT ?title ?date
WHERE {
   :JamesDean :playedIn ?movie .
   ?movie rdfs:label ?title .
   ?movie dc:date ?date .
}
ORDER BY ?title
LIMIT 1
#+END_SRC

*** Another example
#+BEGIN_SRC xml
SELECT ?title WHERE {
   :JamesDean :playedIn ?movie .
   ?movie rdfs:label ?title .
   ?movie dc:date ?date .
}
ORDER BY DESC ?title

#+END_SRC
** Aggregates and grouping
+ Aggregate functions
 – COUNT
 – MIN
 – MAX
 – AVG
 – SUM
*** Example 1
#+BEGIN_SRC xml
SELECT (COUNT (?movie) AS ?howmany)
WHERE {
   :JamesDean ?playedIn ?movie .
}
#+END_SRC

*** Consider the following example
| Company | Amount | Year |
|---------+--------+------|
| ACME    | $1250  | 2010 |
| PRIME   | $3000  | 2009 |
| ABC     | $2500  | 2009 |
| ABC     | $2800  | 2010 |
| PRIME   | $1950  | 2010 |
| ACME    | $2500  | 2009 |
| ACME    | $3100  | 2010 |
| ABC     | $1500  | 2009 |
| ACME    | $1250  | 2009 |
| PRIME   | $2350  | 2009 |
| PRIME   | $1850  | 2010 |

**** In Triples
Each row has 4 triples
:row1 a :Sale .
:row1 :company :ACME .
:row1 :amount : 1250 .
:row1 :year 2010

** SUM
#+BEGIN_SRC xml
SELECT (SUM (?val) AS ?total)
WHERE {
   ?s a: Sale .
   ?s :amount ?val
}
#+END_SRC

** GROUP BY
#+BEGIN_SRC xml
SELECT ?year (SUM (?val) AS ?total)
WHERE {
   ?s a: Sale .
   ?s :amount ?val . ?s :year ?year
}
GROUP BY ?year
#+END_SRC

** Another example
#+BEGIN_SRC xml
  SELECT ?year ?company (SUM (?val) AS ?total)
  WHERE {
     ?s a: Sale .
     ?s :amount ?val . ?s :year ?year .
     ?s :company ?company
}
GROUP BY ?year ?company
#+END_SRC

** HAVING
#+BEGIN_SRC xml
SELECT ?year ?company (SUM (?val) AS ?total)
WHERE {
   ?s a: Sale .
   ?s :amount ?val .
   ?s :year ?year .
   ?s :company ?company
}
GROUP BY ?year ?company
HAVING (?total > 5000)
#+END_SRC
** UNION
+ Combines two graph patterns
+ Variables in each pattern takes values independently but the results are combined together

#+BEGIN_SRC xml
SELECT ?actor
WHERE {
       {?actor :playedIn :Giant .}
       UNION
       {?actor :playedIn :RebelWithoutaCause .}
}
#+END_SRC
*** Output
[[./img/union.png]]

** SUBQUERIES
+ Query within a query
+ Generally subquery is not required in SPARQL because SPARQL graph pattern can include arbitrary connections between variables and resource identifiers
+ However subqueries are useful when combining limits and aggregates with other graph patterns.

*** Example: Subquery to compute total sales for 2009 and 2010
[[./img/subqueryExample.png]]

**** Output
?Company
ACME


*** Another example: Using subquery in CONSTRUCT
[[./img/subqueryForConstruct.png]]

**** Output
#+BEGIN_SRC xml
:PRIME a :PreferredCustomer .
:PRIME :totalSales 5350.00 .
#+END_SRC

** SPARQL Endpoint
+ A server for the SPARQL protocol
 – accepts queries and returns results via HTTP.
   + Generic endpoints will query any Web-accessible RDF data
   + Specific endpoints are hardwired to query against particular datasets
+ Endpoint is identified with a URL and provides flexible access to its data set

*** Various output formats
+ The results of SPARQL queries can be returned and/or rendered in a variety of formats:
 – XML. SPARQL specifies an XML vocabulary for returning tables of results.
 – JSON. A JSON "port" of the XML vocabulary, particularly useful for Web applications.
 – CSV/TSV. Simple textual representations ideal for importing into spreadsheets
 – RDF. Certain SPARQL result clauses trigger RDF responses, which in turn can be serialized in a number of ways (RDF/XML, N-Triples, Turtle, etc.)
 - HTML. When using an interactive form to work with SPARQL queries. Often implemented by applying an XSL transform to XML results.

*** The intention of SPARQL endpoints
+ Give other people and organisations access to your data in a very flexible way
+ Eventually realise the potential of federated SPARQL whereby several SPARQL Endpoints are combined to allow complex queries to be run across a number of datasets
+ They are open for use by a large and varied audience

*** Challenges of using SPARQL endpoint
+ Intermittently available or not available

** Examples of SPARQL Query Editors
+ Rasqal
+ Virtuoso
+ Flint SPARQL query editor

* Ontology Engineering
As you know in Specific Semantic Web Layer, Logic is on the top of OWL and SPARQL is used for query of RDF and OWL documents:
[[./img/ontologyEngineering.png]]

** Query Languages
The SPARQL searches for sets of triples matching given patterns and is human-friendly pattern of search.
Without query languages, questions cannot be answered and since, Web Semantic is involved with answering questions, these query languages (like SPARQL) play a  key role in Web Semantic.

** Using select-from-where
- As in SQL, SPARQL queries have a SELECT-FROM-WHERE structure:
 + SELECT specifies the projection: the number and order of retrieved data
 + FROM is used to specify the source being queried (optional)
 + WHERE imposes constraints on possible solutions in the form of graph pattern templates and boolean constraints

- Retrieve all phone numbers of staff members:

#+BEGIN_SRC xml
SELECT ?x ?y
		WHERE
		{ ?x uni:phone ?y .}
#+END_SRC

- Here ?x and ?y are variables, and ?x uni:phone ?y represents a resource-property-value triple pattern

** Explicit Join
- Retrieve the name of all courses taught by the lecturer with ID 949352
#+BEGIN_SRC xml
SELECT ?n
WHERE
{
	?x rdf:type uni:Course ;
		uni:isTaughtBy :949352 .
	?x uni:name ?n .
}
#+END_SRC

** Categories
Categories are the base of semantic Web and are called (i) domains (in databases), (ii) types (in Artificial intelligence), (iii) classes (in object oriented programming), and (iv) concepts(in logic). Sets can show Categories. For instance, subclasses can be shown with:

[[./img/categories.png]]

** Constructing Ontologies Manually
- In Web Semantic, Ontology is a key factor. Logic has no vocabulary. Ontology fills such a gap, and there are 8 main Stages in Ontology Development:
1. Determine scope
2. Consider reuse
3. Enumerate terms
4. Define taxonomy
5. Define properties
6. Define facets (cardinality, symmetry, transitivity,…………)
7. Define instances
8. Check for anomalies

Not a linear process!

** Reusing Existing Ontologies
*** Existing Domain-Specific Ontologies
There are many domains for ontology,  for instance:

- Medical domain: Cancer ontology from the National Cancer Institute in the United States
- Cultural domain:
 + Art and Architecture Thesaurus (AAT)  with 125,000 terms in the cultural domain
 + Union List of Artist Names (ULAN), with 220,000 entries on artists
 + Iconclass vocabulary of 28,000 terms for describing cultural images
- Geographical domain: Getty Thesaurus of Geographic Names (TGN), containing over 1 million entries

*** Integrated Vocabularies
- Merge independently developed vocabularies into a single large resource
- E.g. Unified Medical Language System integrating 100 biomedical vocabularies
 + The UMLS metathesaurus contains 750,000 concepts, with over 10 million links between them
- The semantics of a resource that integrates many independently developed vocabularies is rather low
 + But very useful in many applications as starting point

*** Upper-Level Ontologies
- Some attempts have been made to define  generally applicable ontologies
 + Mot domain-specific
- Cyc, with 60,000 assertions on 6,000 concepts
- Standard Upperlevel Ontology (SUO)

*** Topic Hierarchies
+ Some “ontologies” do not deserve this name:
 - simply sets of terms, loosely organized in a hierarchy
+ This hierarchy is typically not a strict taxonomy but rather mixes different specialization relations (e.g. is-a, part-of, contained-in)
+ Such resources often very useful as starting point
+ Example: Open Directory hierarchy, containing more than 400,000 hierarchically organized categories and available in RDF format

*** Linguistic Resources
- Some resources were originally built not as abstractions of a particular domain, but rather as linguistic resources
- These have been shown to be useful as starting places for ontology development
 + E.g. WordNet, with over 90,000 word senses

*** Ontology Libraries
+ Attempts are currently underway to construct online libraries of online ontologies
 - Rarely existing ontologies can be reused without changes
 - Existing concepts and properties must be refined using rdfs:subClassOf and rdfs:subPropertyOf
 - Alternative names must be introduced which are better suited to the particular domain using owl:equivalentClass and owl:equivalentProperty
- We can exploit the fact that RDF and OWL allow private refinements of classes defined in other ontologies

** Semiautomatic Ontology Acquisition
*** The Knowledge Acquisition Bottleneck
+ Manual ontology acquisition remains a time-consuming, expensive, highly skilled, and sometimes cumbersome task
+ Machine Learning techniques may be used to alleviate
 - knowledge acquisition or extraction
 - knowledge revision or maintenance

*** Tasks Supported by Machine Learning :
+ Extraction of ontologies from existing data on the Web
+ Extraction of relational data and metadata from existing data on the Web
+ Merging and mapping ontologies by analyzing extensions of concepts
+ Maintaining ontologies by analyzing instance data

*** Useful Machine Learning Techniques for Ontology Engineering:
+ Clustering
+ Incremental ontology updating
+ Support for the knowledge engineering
+ Improving large natural language ontologies
+ ontology learning

** Ontology Mapping
+ A single ontology will rarely fulfill the needs of a particular application; multiple ontologies will have to be combined
+ This raises the problem of ontology integration (also called ontology mapping)
+ Current major approaches in ontology mapping are:
 1. linguistic,
 2. statistical,
 3. structural, and
 4. logical methods

+ Each of these four important methods will be discussed in detail in the next slides:

*** Linguistic methods
+ The most basic methods try to exploit the linguistic labels attached to the concepts in source and target ontology in order to discover potential matches

*** Statistical Methods
+ A significant statistical correlation between the instances of a source concept and a target concept, gives us reason to believe that these concepts are strongly related.

+ These approaches rely on the availability of a sufficiently large amount of instances that are classified in both the source and the target  ontologies.

*** Structural Methods
+ Since ontologies have internal structure, it makes sense to exploit the graph structure of the source and the target ontologies and try to determine similarities, often in coordination with other methods.
 - If a source target and a target concept have similar linguistic labels, then the dissimilarity of their graph neighborhoods could be used to detect homonym problems where purely linguistic methods would falsely declare a potential mapping

*** Logical Methods
+ The most specific to mapping ontologies
+ A serious limitation of this approach is that many practical ontologies are semantically rather lightweight and thus don’t carry much logical formalism with them.
+ In any case, if an ontology carries heavy logical formalism, logical methods can be effectively used for its mapping.

*** Ontology-Mapping Techniques Conclusion
+ Although there is much potential, and indeed need, for these techniques to be deployed for Semantic Web engineering, this is far from a well-understood area
+ For Ontology-Mapping , no off-the-shelf techniques are currently available, and it is not clear that this is likely to change in the near future.

** Architecture
+ Building the Semantic  Web or in fact its architecture involves :
 - Knowledge Acquisition
 - Knowledge Storage
 - Query Languages, and
 - Knowledge Maintenance

*** Knowledge Acquisition
+ Initially, tools must exist that use surface analysis techniques to obtain content from documents
 - Unstructured natural language documents: statistical techniques and shallow natural language technology
 - Structured and semi-structured documents: wrappers induction, pattern recognition

*** Knowledge Storage
+ The output of the analysis tools is sets of concepts, organized in a shallow concept hierarchy with at best very few cross-taxonomical relationships
+ RDF/RDF Schema are sufficiently expressive to represent the extracted info
 - Store the knowledge produced by the extraction tools
 - Retrieve this knowledge, preferably using a structured query language

* Description logic program (DLP)
+ Intersection of Horn Logic and OWL is called DLP (Description Logic Program).
+ the relation of OWL Description Logic Program (DLP) to other languages:
[[./img/DLP.png]]
Note that here by logic program we mean a finite set of facts and rules and not a computer program.

** Equivalent terms:
 + In OWL:   in Description  Logic:
 + class   = concept
 + property= role
 + Object  = individual

** In Description logic Program  (DLP) we can use:
+ intersection or conjunction of concepts C and D
+ union or disjunction of concepts C or
+ negation or complement of concepts not
+ universal restriction in C
+ existential restriction in C

** Knowledge Representation
+ The subjects presented so far were related to the representation of knowledge
+ Knowledge Representation was studied long before the emergence of WWW in AI
+ Logic is still the foundation of KR, particularly in the form of predicate logic (first-order logic)

[[./img/DLPone.png]]

[[./img/DLPtwo.png]]

** Three Exercises
*** Exercise 1: Express the following as facts, rules, and questions
+ “clyde” is a Tiger
+ “simi” is a rabbit
+ Rabbits hate tigers
+ Rabbit is a Species
+ Tiger is a Species
+ --------------------
+ Is “clyde” a Species?
+ Does “simi” like “clyde”?

**** Answer:
+ Facts:
 - Tiger(clyde)
 - Rabbit(simi)

+ Rules:
 - Hate(X,Y) -> ¬ Like (X,Y)
 - Rabbit(X), Tiger(Y) -> Hate(X,Y)
 - Rabbit(X) -> Species(X)
 - Tiger(X) -> Species(X)

+ Questions:
 - -> Species(clyde)
 - -> Like(simi,clyde)

*** Exercise 2:
+ Consider the following facts in a database about family relationships:
 - mother(X,Y), X is the mother of Y
 - father(X,Y), X is the father of Y
 - uncle(X,Y), X is the uncle of Y
 - brother(X,Y), X is the brother of Y
 - sister(X,Y), X is the sister of Y
 - notSame(X,Y), X is not the same as Y
 - male(X), X is male
 - female(X), X is female

a) Express a rule showing
 X is the grandmother of y

b) Express a pair of rules showing X is a half-sister  of Y

**** Answer:
a) mother(X,P), parent(P,Y) -> grandmother(X,Y)
b) female(X),mother(M,X), mother(M,Y), father(F1,X), father(F2,Y), notSame (F1,F2) -> half-sister(X,Y)

female(X), father(F,X), father(F,Y)mother(M1,X), mother(M2,Y), notSame (M1,M2) -> half-sister(X,Y)

*** Exercise 3:
Name the three types of container elements in RDF and provide an example for each of them.

**** Answer:
Three Types of Container Elements
1. rdf:Bag an unordered container, allowing multiple occurrences
 - For example,  members of the faculty board, documents in a folder
2. rdf:Seq an ordered container, which may contain multiple occurrences
 - For example, modules of a course, items on an agenda, an alphabetized list of staff members (order is imposed)
3. rdf:Alt a set of alternatives
 - For example, translations of a document in various languages

* Logic and Inference
[[./img/NestingOfBooleanOperators.png]]

** The Importance of Logic
+ High-level language for expressing knowledge
+ High expressive power
+ Well-understood formal semantics
+ Precise notion of logical consequence
+ Proof systems that can automatically derive statements syntactically from a set of premises
+ There exist proof systems for which semantic logical consequence coincides with syntactic derivation within the proof system
 - Soundness & completeness
+ Predicate logic is unique in the sense that sound and complete proof systems do exist.
 - Not for more expressive logics (higher-order logics)
+ trace the proof that leads to a logical consequence.
+ Logic can provide explanations for answers
 - By tracing a proof

** Specializations of Predicate Logic:RDF and OWL
+ The languages of RDF and OWL can be viewed  as specializations of predicate logic (first order logic).
+ More expressive logics (higher order logics) do not have such proof systems.
+ Predicate logic and its special cases are monotonic, in the sense that, if a conclusion can be drawn, it remains valid even if new knowledge becomes available.
+ RDF/S and OWL (Lite and DL) as specializations of predicate logic correspond roughly to a description logic  (DL).
+ They define reasonable subsets of logic
+ Trade-off between the expressive power and the computational complexity:
 - The more expressive the language, the less efficient the corresponding proof systems

** Horn Logic
In Horn Logic a rule is represented as:
 A1, . . ., An -> B

*** Specializations of Predicate Logic: Horn Logic
+ A rule has the form: A1, . . ., An -> B
 - Ai and B are atomic formulas
+ In Horn logic, there are 2 ways of reading such a rule:
 - Deductive rules: If A1,..., An  are known to be true, then B is also true
 - Reactive rules: If the conditions A1,..., An  are true, then carry out the action B

** Description Logics vs. Horn Logic
+ Neither of them is a subset of the other
+ It is impossible to assert that a person X who is brother of Y is uncle of Z (where Z is child of Y) in OWL
 - This can be done easily using rules: brother(X,Y), childOf(Z,Y) -> uncle(X,Z)
+ Rules cannot assert the information that a person is either a man or a woman
 - This information is easily expressed in OWL using disjoint union

** Monotonic vs. Non-monotonic Rules
+ Example: An online vendor wants to give a special discount if it is a customer’s birthday

+ Solution 1
 - R1: If birthday, then special discount
 - R2: If not birthday, then not special discount

But what happens if a customer refuses to provide his birthday due to privacy concerns?

+ Solution 2
 - R1: If birthday, then special discount
 - R2’: If birthday is not known, then not special discount

+ Solves the problem but: The premise of rule R2' is not within the expressive power of predicate logic We need a new kind of rule system

+ The solution with rules R1 and R2 works in case we have complete information about the situation
+ The new kind of rule system will find application in cases where the available information is incomplete
+ R2’ is a nonmonotonic rule

** Exchange of Rules
+ Exchange of rules across different applications
 - E.g., an online store advertises its pricing, refund, and privacy policies, expressed using rules
+ The Semantic Web approach is to express the knowledge in a machine-accessible way using one of the Web languages we have already discussed
+ We show how rules can be expressed in XML-like languages (“rule markup languages”)
+ Information of a logic program can be provided from different websites.
+ A crawler is a compute program which visits Web sites and reads their pages and then parses the information in these web site to visit other websites!!
+ Crawlers can  create entries for a search engines
+ All search engines on the Web  have such a program.
+ The term  crawler signifies  the fact that they crawl through an entire site a page at a time. A crawler crawls different sites following the links to other sites.
+ For doing such a highly sophisticated task, they can be programmed in an extremely easy recursive fashion.

[[./img/ClassHierarchyforRDFSchema.png]]

+ XPATH and SPARQL are for searching RDF files. Whereas XPATH works for all XML files, including RDF, SPARQL cannot search any XML files and needs triplets to search:
 - Subject, Property ,Object
 - I LIKE RDF
 - YOU GET THE-CD
 - FRED PUSHED THE-TABLE
 - THE-RACE-CAR HAS_SPEED_OF 300_KM/HOUR

+ What is XPath?
 - XPath is a syntax for defining parts of an XML document
 - XPath uses path expressions to navigate in XML documents
 - XPath contains a library of standard functions
 - XPath is a major element in XSLT
 - XPath is a W3C recommendation
[[./img/xpath.png]]

*** example
- Assume you have a Person class and property called parent. Both the domain and range of parent is Person. In the following we write DL query to display the grandparents of “Jim” which is a member of Person class:
 + Person and parent some (parent value Jim)
- Note to the usage of and, some, and value in DL
- As you know, OWL and RDF do not make the Unique Name Assumption:
 + If you assert p(a,b) and p(a,c) and then ask for p min 2 in DL, you will not obtain  a , because it could be that b=c , and in that case “a” may not have necessarily two values for p !!
 + However if you assert that b ≠ c, then p min 2 in DL will result to a.
+ If you go to “Edit” menu item and select “Make all individuals Distinct”, then all of your current individuals will become distinct from one another. Try not to do so, as this makes some reasoners confused!

*** example
Assume  you have the following ontology

:hasPet    a           owl:ObjectProperty;
        rdfs:domain :Human;
        rdfs:range  :Animal;
:Tim    a           :Human;
        hasPet      :dogy.

hasPet exactly 1 Animal
does not return  Tim because if we do know that he has dogy, it does not mean that he has not any other animal.  This is Open World Assumptions OWL sticks to !  Maybe we are not aware of:
:Tom     hasPet      :catten, mousy.

In other words, OWL and RDF doe not assume that the provided data  are exhaustive enumeration of everything in the world and that there may be many things that are true and are not in the owl  (or rdf) document
:what

More Plainlely:

The absence of an assertion of p (a, c) does not imply that 
not( p (a, c) ),
but rather just that there is no judgment yet on 
p (a, c)
In fact, unlike in databases, in open world reasoning  nothing is assumed to be false unless it has explicitly been stated !


 Go to the Individuals tab, select Tim, click the "+" button next to Types, go to the Class expression editor tab, and enter,

hasPet  only { Dogy }

And the problem will be solved. Now
hasPet excatly 1
Will result to    Tim !

The reason is that not only Tim is in the class Person but in the class:
 hasPet  only { Dogy }
As well !


*** example
Assume there are three colours:
Colours :{red,  white,  blue}
And in the set Flower, every flower can have one or  more colour(s).
The following DL query
        Flower and hasColor value red
does return any flower with red colour but not every flower with ONLY red colour.
Even changing it to
          Flower and (hasColor only {red})
 does not solve the problem.    WHY?

**** ANSWER
 Because OWL uses the open world assumption. and  if we know that  a  flower has red colour, it does not mean that it does not have other colour. It can have other colours not stated in the dataset.
Again the solution is to go to the Individuals tab, select flower1, click the "+" button next to Types, go to the Class expression editor tab, and enter,

hasColour  only { red }
In DL, the difference between some and only is as follows:
  when we say that we look for a flower that has some colour red and white, if a flower is white and yellow is selected, however,
when we say that we look for a flower that has only colour red and white then a flower which is red or white or (red and white) is selected but  a flower which has some extra colour is not slected !
   In fact ”only” is about closure and closes off extra options, whereas ”some” does not do so.

* 8 steps of ontology development process
1. Determine scope
2. Consider reuse
3. Enumerate terms
4. Define taxonomy
5. Define properties
6. Define facets
7. Define instances
8. Check for anomalies

** Step 1. Determine scope
+ Ontology is a model/abstraction of a domain
+ Should be determined by the use of which the ontology will be put and by future extensions
+ Basic questions to ask
 – What is the domain that the ontology will cover
 – For what we are going to use the ontology
 – For what types of questions should the ontology provide answers
 – Who will use and maintain the ontology

*** Competency questions
+ One of the easy ways to determine scope of ontology is to develop competency questions
+ Example: Wine and food domain
 – Which wine characteristics should I consider when choosing a wine?
 – What is the best choice of wine for grilled meat?
 – Which characteristics of a wine affect its appropriateness for a dish?
 – Does Cabernet Sauvignon go well with seafood?

*** Example: Food and wines (1)
+ We plan to use this ontology for the applications that suggest good combinations of wines and food.
 – Naturally, the concepts describing different types of wines, main food types, the notion of a good combination of wine and food and a bad combination will figure into our ontology.
+ It is unlikely that the ontology will include concepts for managing inventory in a winery or employees in a restaurant even though these concepts are somewhat related to the notions of wine and food.
+ If the ontology will be used to help restaurant customers decide which wine to order, we need to include retail-pricing information.
+ If it is used for wine buyers in stocking a wine cellar, wholesale pricing and availability may be necessary.

** Step 2. Consider reuse
+ Rarely we have to start from scratch when defining ontology
 – Reusing existing ontologies may be a requirement if our system needs to interact with other applications that have already committed to particular ontologies or controlled vocabularies.
+ Look for third-party that provides a useful starting point for ontology

*** Example: Food and wines
+ A knowledge base of French wines may already exist
 – If we can import this knowledge base and the ontology on which it is based, we will have not only the classification of French wines but also the first pass at the classification of wine characteristics used t o distinguish and describe the wines.
+ Lists of wine properties may already be available from commercial Web sites such as www.wines.com that customers consider use to buy wines.

** Step 3. Enumerate terms
+ Useful first step is to write down in an unstructured list all relevant terms that are expected to appear in the ontology
 – nouns -> class names
 – verbs/phrases –> property names (e.g. hasComponent, isPartOf)

*** Example: Food and wines
+ Wine-related terms will include
 – Wine, grape, winery, location, a wine’s color, body, flavor and sugar content;
 – Different types of food, such as fish and red meat;
 – Subtypes of wine such as white wine, and so on.

** Step 4. Define taxonomy
+ Organise terms identified in step 3 into taxonomic hierarchy
 – Can use bottom-up or top-down approach
 – Hierarchy – class/subclass
+ Threeapproaches
 – Top-down
 – Bottom-up
 – Combination

*** Top-down
+ Starts with the definition of the most general concepts in the domain and subsequent specialization of the concepts.
+ Example
 – We can start with creating classes for the general concepts of Wine and Food.
 – Then we specialize the Wine class by creating some of its subclasses: White wine, Red wine, Rosé wine.
 – We can further categorize the Red wine class, for example, into Shiraz, Red Burgundy, Cabernet Sauvignon, and so on.

*** Bottom-up
+ Starts with the definition of the most specific classes, the leaves of the hierarchy, with subsequent grouping of these classes into more general concepts.
+ Example
 – We start by defining classes for Pauillac and Margaux wines.
 – We then create a common superclass for these two classes—Medoc—which in turn is a subclass of Bordeaux.

*** Combination
+ Is a combination of the top-down and bottom-up approaches
 – We define the more salient concepts first and then generalize and specialize them appropriately
+ may result in middle-level concept

** Step 5. Define properties
+ Often interleaved with step 4
+ Organise properties that link the classes while organising these classes in a hierarchy
+ Provide domain and range to properties
 – need to balance between generality and specificity
   + e.g. broad/general enable properties to be used by subclasses (through inheritance)
   + too narrow/specific  may create inconsistencies through domain and range violations

*** Different types of object properties
+ Intrinsicproperty
+ Extrinsicproperty
+ Parts(canbebothphysicalandabstractparts) • Relationshipstootherindividuals
+ Example:
 – Intrinsic – flavour of wine
 – Extrinsic – wine’s name, area where it comes from
 – Parts – courses of a meal
 – Relationship: maker of the wine

** Step 6. Define facets
+ Consider
 – Cardinality
  + Minimum and maximum cardinalities
  + E.G. Allowed to have a certain number of different values (e.G. At least one pizzatopping; at most one pizzabase)
 - Value types: string, number, boolean, enumerated
 – Required values
 – Relational characteristics
  + Symmetry, transitivity, inverse properties, functional values

** Step 7. Define instances
+ Defining an individual instance of a class requires
 1. Choosing a class,
 2. Creating an individual instance of that class, and
 3. Filling in the values.
+ Fill in instances
 – can retrieve from databases
 – often is not done manually due to the large number of instances

** Step 8. Check for anomalies
+ Check for consistencies
+ Examples of anomalies
 – Incompatible domain and range definitions for transitive, symmetric or inverse properties
 – Inconsistent cardinalities
 – Property values conflict with domain and restriction

* What is Reasoning?
+ Reasoning is the cognitive process of looking for reasons for beliefs, conclusions, actions or feelings
+ The world does not give us complete information
+ Reasoning is the set of processes that enables us to go beyond the information given
+ Reasoning in most of the cases is based on Logic

* Three species of OWL
+ OWL Lite
 – Classification hierarchies with simple constraints
 – Reasoning is computational simple & efficient
+ OWL DL
 – Computational complete and decidable (computation in finite time)
 – Corresponds to description logic
+ OWL Full
 – Maximum expressiveness
 – No computational guarantee

** The “DL” in OWL DL
+ Description Logics
+ Goal: to be able to reason (i.e. infer information) about a knowledge base
 – A knowledge base consists of both meta information (classes) and instance information (individuals)

* Open world assumption
+ Consider the following example:

 Statement: "Mary" "is a citizen of" "France"
 Question: Is Paul a citizen of France?

+ "Closed world" (for example SQL) answer: No.
+ "Open world" answer: Unknown.

** closed world vs. Open World
[[./img/closedWorldVSopenWorld.png]]

* Description Logics
+ Highly expressible fragment of first-order logic with
 – Decidability
  + Guaranteed that computation can be done in finite time
 – Completeness
  + Every question within the logical system can be answered

+ Designed for logical representation of object-oriented formalisms
 – Frames/classes/concepts
  + Sets of objects
 – Roles/properties
  + Binary relations on objects
 – Individuals

+ Represented as a collection of statements, with unary & binary predicates that stand for concepts and roles, from which deductions can be made

** Description Logic Syntax - Concepts
+ Classes/concepts are actually a set of individuals
+ We can distinguish different types of concepts:
 – Atomic concepts: Cannot be further decomposed (i.e. Person)
 – Incomplete concepts (defined by   )
  + necessary condition
 – Complete concepts (defined by ≡)
  + necessary and sufficient condition

** Incomplete concept defintion
+ Man   Person   Male
 – Intended meaning: If an individual is a man, we can conclude that it is a person and male.
+ Man(x)   Person(x)   Male(x)
+ In Protege
 – necessary conditions are called primitive class

** Complete concept definition
+ Man ≡ Person   Male
 – Intended meaning: Every individual which is a male person is a man, and every man is a male person.
+ Man(x) Person(x) Male(x)
+ In Protégé
 – necessary and sufficient conditions are called Equivalent classes (defined class)

** Description Logic Syntax- Roles
+ Rolesrelateindividualstoeachother
 – I.e. directedBy(Pool Sharks, Edwin Middleton), hasChild(Jonny, Sue)
+ Roleshaveadomainandarange
+ Example:
 – Domain(directedBy, Movie)
 – Range(directedBy, Person)
  + Given the above definitions we can conclude that Pool Sharks is a movie and that Edwin Middleton is a person.
+ FunctionalRoles
 – Roles which have exactly one value
 – Usually used with primitive data values
+ TransitiveRoles
 – Example: hasAncestor
Simple in a rule language:
hasAncestor(X,Z) -> hasAncestor(X,Y), hasAncestor(Y,Z).

+ SymmetricRoles
 – Roles which hold in both directions
 – I.e. hasSpouse, hasSibling

+ InverseRoles
 – Roles are directed, but each role can have an inverse
 – I.e. hasParent ≡ hasChild  hasParent(X,Y)   hasChild(Y,X)

** Description Logic Knowledge Bases
+ Typically a DL knowledge base (KB) consists of two components
 – Tbox (terminology/terminological knowledge): A set of inclusion/equivalence axioms denoting the conceptual schema/vocabulary of a domain
  + Bear   Animal   Large
  + transitive(hasAncestor)
 – Abox (assertions/assertional knowledge): concept assertions and role assertions
  + Bear(WinniPooh)
  + hasAncestor(Susan, Granny)

** DL and reasoning
+ Modern DL systems provide their users with reasoning services that can automatically deduce implicit knowledge from the explicitly represented knowledge, and always yield a correct answer in finite time.
